# переменная — по сути, это имя,
# объекты — это области памяти для хранения значений,
# ссылки — указатели от имени к области памяти.

# изменяемые объекты: 
# "mutable": ("словарь", "список", "множество")

# С неизменяемыми объектами сделать так не получится.

# Например:
# x = (1, 2, 3)
# x[0] = 5 — попытка изменения кортежа приведёт к ошибке:

# TypeError: 'tuple' object does not support item assignment

# Но это не значит, что неизменяемые объекты хуже. 
# Так как они не поддерживают такой довольно сложный механизм, 
# они затрачивают меньше памяти на хранение тех же самых данных.

import sys

test_list = list()
test_tuple = tuple()

print(sys.getsizeof((test_list)))
print(sys.getsizeof((test_tuple)))  # - кортеж будет весить меньше.


# L2 = L1[:] 
# — популярный метод копирования, при котором мы, по сути, 
# создаём новый объект из среза со всеми элементами старого списка.
# В итоге L2 будет ссылаться уже на новый список, не связанный с оригинальным списком L1.
# более универсальный способ — использование метода copy().
dist = {1: 2, 3: 4}
x = dist.copy()
x[1] = 5
print(x, dist) # — значение по ключу 1 будет разным в этих двух объектах.

# изменяемые типы данных не могут быть использованы в качестве ключей.
# В Python copy() буквально копирует объект, и, если в объекте есть ссылки, они тоже копируются.

import copy
list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
list_of_lists_2 = list_of_lists.copy()
list_of_lists[0][0] = 10 # — изменение во вложенном списке.
print(list_of_lists)
print(list_of_lists_2)
[[10, 2, 3], 4, [5, 6, 7]]
[[10, 2, 3], 4, [5, 6, 7]] 
# — будут отражаться и в копии списка, 
# так как копия имеет точно такие же ссылки, какие были в оригинале.
# В итоге мы как будто получаем не полную копию, а только поверхностную копию списка.

# Именно эту проблему решает функция deepcopy из модуля copy.

list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
list_of_lists_2 = copy.deepcopy(list_of_lists)
list_of_lists[0][0] = 10
print(list_of_lists)
print(list_of_lists_2)
[[10, 2, 3], 4, [5, 6, 7]]
[[1, 2, 3], 4, [5, 6, 7]] # — теперь изменения не отражаются в копии.

# Deepcopy, по сути, рекурсивно прошла по всем вложенным спискам 
# и к каждому применила copy(), создав копии всех вложенных объектов.

# Основные моменты
# Переменные — это ссылки на область памяти с объектом, а не сам объект.
# На один объект может ссылаться несколько переменных. 
# Если мы вносим какие-то правки в изменяемый объект, то это будет 
# отражено во всех переменных, которые ссылались на этот объект.
# Чтобы изменения в одной переменной не касались другой переменной, 
# нужно использовать копирование объектов (чтобы каждая переменная ссылалась на свой объект).
# Копирование можно выполнять при помощи срезов (сделать срез со всеми элементами) 
# или при помощи специального метода copy (или deepcopy из модуля copy).