# Рекурсия — это мощный инструмент в программировании, позволяющий решать сложные 
# задачи путём разбиения на более простые подзадачи. 

# В этом материале вы узнаете о популярных алгоритмах на языке Python, 
# основанных на использовании рекурсии: 
# факториале, числах Фибоначчи, бинарном поиске и глубоком копировании.

# Факториал
# Факториал числа n (обозначается как n!) определяется как произведение 
# всех натуральных чисел от 1 до n. 

# Пример
5! = 5 * 4 * 3 * 2 * 1 = 120.

# Можно реализовать вычисление факториала с помощью рекурсии так:

def factorial(number):
    if number == 1:
        # Если number равно 1, то возвращаем 1, так как факториал 1 равен 1.
        return 1
    else:
        # Если number больше 1, то вычисляем факториал (number - 1) и умножаем на number.
        return number * factorial(number - 1)
# Пример использования
print(factorial(5)) # 120



# Числа Фибоначчи
# Числа Фибоначчи — это последовательность чисел, где каждое следующее число 
# равно сумме двух предыдущих. Например, первые несколько 
# чисел Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 и так далее.
# Статья о числах Фибоначчи в «Википедии»

# Вычисление чисел Фибоначчи с помощью рекурсии:
def fibonacci(number):
    if number <= 1:
        # Если число меньше или равно 1, то возвращаем его.
        return number
    else:
        # Если число больше 1, то вычисляем сумму двух предыдущих чисел Фибоначчи.
        return fibonacci(number - 1) + fibonacci(number - 2)
    


# Бинарный поиск
# Бинарный поиск — это алгоритм поиска элемента в отсортированной 
# последовательности путём её разделения на две равные части и поиска элемента 
# в соответствующей половине. Если элемент не найден, то поиск повторяется в половине, 
# в которой может быть элемент. 

# Эту идею мы уже реализовали в задаче «Угадай число», где надо было отгадать 
# загаданное число за семь попыток. Также бинарный поиск можно реализовать при помощи рекурсии:
def binary_search(arr, x, start, end):
    # arr — список всех элементов;
    # x — элемент, который мы ищем;
    # start — первый индекс;
    # end — последний индекс;
    # то есть start/end — границы поиска внутри списка.
    if start > end:
        # Если начальный индекс больше конечного, то элемент не найден, возвращаем -1.
        # Это будет значить, что мы не нашли нужное число.
        return - 1
    # Иначе находим индекс среднего элемента.
    mid = (start + end) // 2
    if arr[mid] == x:
        # Если средний элемент равен искомому элементу, то возвращаем его индекс.
        return mid
    elif arr[mid] < x:
        # Если средний элемент меньше искомого элемента, то ищем элемент 
        # во второй половине списка (после среднего элемента).
        return binary_search(arr, x, mid + 1, end)
    else:
        # Если средний элемент больше искомого элемента, то ищем элемент 
        # в первой половине списка (до среднего элемента).
        return binary_search(arr, x, start, mid - 1)
    
    