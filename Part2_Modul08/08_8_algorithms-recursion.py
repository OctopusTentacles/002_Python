# Рекурсия — это мощный инструмент в программировании, позволяющий решать сложные 
# задачи путём разбиения на более простые подзадачи. 

# В этом материале вы узнаете о популярных алгоритмах на языке Python, 
# основанных на использовании рекурсии: 
# факториале, числах Фибоначчи, бинарном поиске и глубоком копировании.



# Факториал
# Факториал числа n (обозначается как n!) определяется как произведение 
# всех натуральных чисел от 1 до n. 
# Пример
# 5! = 5 * 4 * 3 * 2 * 1 = 120.
# Можно реализовать вычисление факториала с помощью рекурсии так:

def factorial(number):
    if number == 1:
        # Если number равно 1, то возвращаем 1, так как факториал 1 равен 1.
        return 1
    else:
        # Если number больше 1, то вычисляем факториал (number - 1) и умножаем на number.
        return number * factorial(number - 1)
# Пример использования
print(factorial(5)) # 120




# Числа Фибоначчи
# Числа Фибоначчи — это последовательность чисел, где каждое следующее число 
# равно сумме двух предыдущих. Например, первые несколько 
# чисел Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 и так далее.
# Статья о числах Фибоначчи в «Википедии»

# Вычисление чисел Фибоначчи с помощью рекурсии:
def fibonacci(number):
    if number <= 1:
        # Если число меньше или равно 1, то возвращаем его.
        return number
    else:
        # Если число больше 1, то вычисляем сумму двух предыдущих чисел Фибоначчи.
        return fibonacci(number - 1) + fibonacci(number - 2)
    


# Бинарный поиск
# Бинарный поиск — это алгоритм поиска элемента в отсортированной 
# последовательности путём её разделения на две равные части и поиска элемента 
# в соответствующей половине. Если элемент не найден, то поиск повторяется в половине, 
# в которой может быть элемент. 

# Эту идею мы уже реализовали в задаче «Угадай число», где надо было отгадать 
# загаданное число за семь попыток. Также бинарный поиск можно реализовать при помощи рекурсии:
def binary_search(arr, x, start, end):
    # arr — список всех элементов;
    # x — элемент, который мы ищем;
    # start — первый индекс;
    # end — последний индекс;
    # то есть start/end — границы поиска внутри списка.
    if start > end:
        # Если начальный индекс больше конечного, то элемент не найден, возвращаем -1.
        # Это будет значить, что мы не нашли нужное число.
        return - 1
    # Иначе находим индекс среднего элемента.
    mid = (start + end) // 2
    if arr[mid] == x:
        # Если средний элемент равен искомому элементу, то возвращаем его индекс.
        return mid
    elif arr[mid] < x:
        # Если средний элемент меньше искомого элемента, то ищем элемент 
        # во второй половине списка (после среднего элемента).
        return binary_search(arr, x, mid + 1, end)
    else:
        # Если средний элемент больше искомого элемента, то ищем элемент 
        # в первой половине списка (до среднего элемента).
        return binary_search(arr, x, start, mid - 1)
    


# Глубокое копирование
# Глубокое копирование (deep copy) — это процесс создания нового объекта, 
# который является копией другого объекта, но при этом все вложенные объекты 
# внутри него также копируются, а не просто ссылаются на исходные объекты.

# Работать со вложенными объектами обычными способами довольно непросто 
# (мы заранее можем и не знать, сколько в объекте будет уровней вложенности). 
# Но рекурсия как раз отлично подходит для решения таких задач, так как для каждой 
# вложенной структуры мы можем сделать свой рекурсивный вызов функции, а он при 
# необходимости (если в этом объекте будут вложенные элементы) вызовет для каждого 
# объекта ещё по рекурсивному вызову. В итоге мы обработаем все уровни вложенности 
# вне зависимости от того, сколько их будет.

# Реализация алгоритма для разных типов данных может выглядеть так:
import copy
def deep_copy(obj):
    if isinstance(obj, (int, float, bool, str)):
        # Если объект относится к простому типу данных (число, строка, 
        # булевое значение), то он возвращается как есть, так как не может 
        # иметь вложенных объектов.
        return obj
    elif isinstance(obj, list):
        # Если объект представляет собой список, то создаётся новый список, 
        # содержащий копии всех элементов исходного списка.
        # При этом для каждого элемента списка рекурсивно вызывается 
        # функция deep_copy(), чтобы скопировать его содержимое.
        return [deep_copy(item) for item in obj]
    elif isinstance(obj, dict):
        # Если объект — это словарь, то создаётся новый словарь, 
        # содержащий копии всех элементов исходного словаря, так же с 
        # вызовом deep_copy для каждого вложенного объекта.
        return {key: deep_copy(value) for key, value in obj.items()}
    else:
        # Если объект не относится к базовому типу и не является 
        # списком или словарём, используется метод copy.deepcopy() 
        # из стандартной библиотеки Python, чтобы создать глубокую копию.
        return copy.deepcopy(obj)
    
# Применение рекурсии в этом алгоритме позволяет обрабатывать вложенные 
# объекты разных типов и создавать полную глубокую копию исходного объекта, 
# включая все его вложенные элементы.

# Важно отметить, что встроенная функция deepcopy() из стандартной 
# библиотеки Python также позволяет создать глубокую копию объекта. 
# Однако, если мы используем эту функцию для создания копии объекта, 
# который содержит сложные вложенные структуры, это может привести к 
# проблемам с памятью и производительностью. 
# Поэтому использование рекурсивного алгоритма глубокого копирования может 
# быть предпочтительнее в таких случаях, так как у нас будет больше контроля 
# над процессом (мы можем добавить дополнительные проверки и ограничить копирование 
# по своему желанию).
