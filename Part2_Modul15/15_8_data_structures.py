# 15.8 Готовые реализации структур данных: графы, хеш-таблицы и деревья префиксов
# В этом материале вы:

# познакомитесь с теорией о графах, хеш-таблицах, деревьях префиксов;
# узнаете о библиотеках и модулях, которые помогают с ними работать;
# рассмотрите примеры реализации этих структур данных и примеры работ 
# с кодом из библиотек и модулей.

# Графы
# Теория о графах
# Граф — абстрактная структура данных, представляющая собой набор вершин (узлов) 
# и рёбер (связей) между этими вершинами. Его используют для моделирования 
# различных взаимосвязей и отношений между объектами.

# Графы похожи на деревья, так как обе структуры — это наборы узлов и связей 
# между ними. Однако, в отличие от деревьев, графы могут содержать циклы 
# (но не привычные нам циклы for и while, а замкнутые обходы вершин) 
# и необязательно имеют одну корневую вершину.

# Разработка социальных сетей
# Графы могут представлять друзей или связи между людьми, позволяя анализировать 
# сетевую структуру и находить сообщества или влиятельных участников.
# Маршрутизация сетей
# Графы могут моделировать сетевую инфраструктуру, в которой вершины представляют узлы, 
# а рёбра — соединения между ними, что позволяет оптимизировать маршруты передачи данных.
# Оптимизация путей
# В работе курьеров и служб доставки. Применение графов в этом контексте позволяет эффективно 
# находить оптимальные маршруты доставки и учитывать различные факторы, 
# например расстояние, время доставки, пробки и другие ограничения.

# Библиотеки и модули с реализацией графов
# =======================================================================================

# NetworkX

# Установка библиотеки NetworkX

# Убедитесь, что на вашем компьютере установлен Python.
# Откройте командную строку или терминал.
# Установите библиотеку NetworkX с помощью команды pip:
# pip install networkx==3.1

# Установка через pip даст вам доступ к основным функциям библиотеки.

import networkx as nx
import matplotlib.pyplot as plt

# Создание пустого графа
graph = nx.Graph()

# Добавление вершин
graph.add_node("A")
graph.add_nodes_from(["B", "C", "D"])

# Добавление рёбер
graph.add_edge("A", "B")
graph.add_edges_from([("B", "C"), ("C", "D"), ("D", "A")])

# Получение списка вершин и рёбер
nodes = graph.nodes()
edges = graph.edges()

# Визуализация графа
nx.draw(graph, with_labels=True, node_color='lightblue', edge_color='gray')
plt.show()
# =======================================================================================

# Igraph

# Установка библиотеки igraph

# Убедитесь, что на вашем компьютере установлен Python.
# Откройте командную строку или терминал.
# Установите библиотеку igraph с помощью команды pip:
# pip install python-igraph==0.10.4

import igraph as ig

# Создание пустого графа
graph = ig.Graph()

# Добавление вершин
graph.add_vertices(4)

# Добавление рёбер
graph.add_edges([(0, 1), (1, 2), (2, 3), (3, 0)])

# Получение списка вершин и рёбер
nodes = graph.vs
edges = graph.es

# Визуализация графа
layout = graph.layout("circle")
ig.plot(graph, layout=layout, vertex_color='lightblue', edge_color='gray')
# =======================================================================================

# Хеш-таблицы

# Хеш-таблица — структура данных, предназначенная для эффективного хранения и поиска 
# пар «ключ — значение». Она использует хеш-функцию для преобразования ключа в индекс, 
# по которому происходит доступ к значению.

# Кеширование
# Хеш-таблицы могут использоваться для кеширования результатов вычислений или запросов, 
# ускоряя повторные доступы к данным.
# Поиск и индексация
# Хеш-таблицы обеспечивают быстрый доступ к данным по ключу — это полезно, например, 
# при поиске, индексации или установлении соответствий между объектами.

class HashTable:
    def __init__(self):
        self.size = 10 # Размер хеш-таблицы
        self.table = [None] * self.size # Инициализация массива с None

    def _hash_function(self, key):
        return hash(key) % self.size # Хеш-функция, преобразующая ключ в индекс

    def insert(self, key, value):
        index = self._hash_function(key)
        self.table[index] = value # Вставка значения по соответствующему индексу

    def get(self, key):
        index = self._hash_function(key)
        return self.table[index] # Получение значения по ключу

    def remove(self, key):
        index = self._hash_function(key)
        self.table[index] = None # Удаление значения по ключу

# Модуль hashlib для вычисления хеш-значения строки с использованием SHA-256:

import hashlib
data = "Hello, World!"
hash_object = hashlib.sha256(data.encode())
hex_digest = hash_object.hexdigest()
print(hex_digest) # Выводит хеш-значение SHA-256

# Библиотека mmh3 (MurmurHash) для вычисления хеш-значения строки:

import mmh3
data = "Hello, World!"
hash_value = mmh3.hash(data)
print(hash_value)  # Выводит хеш-значение MurmurHash

# Библиотека pyhash для вычисления CRC32 хеш-значения строки:

import pyhash
data = "Hello, World!"
crc32_hasher = pyhash.crc32()
hash_value = crc32_hasher(data)
print(hash_value)  # Выводит хеш-значение CRC32
# =======================================================================================

# Деревья префиксов

# Автодополнение и предложение ввода
# Деревья префиксов позволяют быстро найти все возможные продолжения для заданного префикса. 
# Например, при вводе текста в поисковой системе или текстовом редакторе деревья префиксов 
# могут предложить автодополнение или исправление ошибок.
# Поиск слов в словаре
# Деревья префиксов могут использоваться для эффективного поиска слов в большом словаре. 
# Они могут определить, является ли заданная последовательность символов префиксом слова.
# Анализ геномных данных
# Деревья префиксов широко используются в биоинформатике для поиска и анализа геномных данных. 
# Они могут помочь в поиске повторяющихся последовательностей в геноме или определении наличия 
# конкретных генов или мутаций.

class HashTable:
    def __init__(self):
        # Создаём пустой список, который будет использоваться в качестве основы хеш-таблицы
        self.table = [None] * 10 # Изначально устанавливаем размер таблицы — 10 элементов

    def _hash_function(self, key):
        # Хеш-функция преобразует ключ в индекс таблицы
        # Простейшая хеш-функция — остаток от деления на размер таблицы
        return hash(key) % len(self.table)

    def _get_index(self, key):
        # Получаем индекс элемента в таблице по ключу
        hash_value = self._hash_function(key)
        # Если по этому индексу ещё нет элемента или ключи совпадают, возвращаем индекс
        if self.table[hash_value] is None or self.table[hash_value][0] == key:
            return hash_value
        # В противном случае применяем метод открытой адресации для разрешения коллизий
        else:
            index = (hash_value + 1) % len(self.table) # Используем линейное пробирование
            while self.table[index] is not None and self.table[index][0] != key:
                index = (index + 1) % len(self.table)
            return index

    def insert(self, key, value):
        # Вставляем элемент в хеш-таблицу
        index = self._get_index(key)
        self.table[index] = (key, value)

    def search(self, key):
        # Ищем элемент в хеш-таблице по ключу
        index = self._get_index(key)
        if self.table[index] is not None and self.table[index][0] == key:
            return self.table[index][1] # Возвращаем значение элемента, если он найден
        else:
            return None # Возвращаем None, если элемент не найден

    def delete(self, key):
        # Удаляем элемент из хеш-таблицы по ключу
        index = self._get_index(key)
        if self.table[index] is not None and self.table[index][0] == key:
            self.table[index] = None # Просто удаляем элемент, присваивая ему значение None

# Создаём экземпляр хеш-таблицы
hash_table = HashTable()

# Вставляем элементы в хеш-таблицу
hash_table.insert("apple", 1)
hash_table.insert("banana", 2)
hash_table.insert("orange", 3)

# Ищем элементы в хеш-таблице
print(hash_table.search("apple")) # Вывод: 1
print(hash_table.search("banana")) # Вывод: 2
print(hash_table.search("grape")) # Вывод: None

# Удаляем элемент из хеш-таблицы
hash_table.delete("banana")

# Проверяем, что элемент удалён
print(hash_table.search("banana")) # Вывод: None

# =======================================================================================

# Библиотека pygtrie
# Установка библиотеки pygtrie

# Убедитесь, что на вашем компьютере установлен Python.
# Откройте командную строку или терминал.
# Установите библиотеку pygtrie с помощью команды pip:
# pip install pygtrie==2.5.0

#from pygtrie import Trie

# Создание экземпляра дерева префиксов
trie = Trie()

# Вставка элементов в дерево
trie["apple"] = 1
trie["banana"] = 2
trie["orange"] = 3

# Проверка наличия элементов
print("apple" in trie)  # Вывод: True
print("pear" in trie)  # Вывод: False

# Получение значения элемента
print(trie["banana"])  # Вывод: 2

# Удаление элемента
del trie["banana"]
print("banana" in trie)  # Вывод: False

# Поиск всех элементов с заданным префиксом
prefix_items = trie.items("a")
print(list(prefix_items)) # Вывод: [(('a', 'p', 'p', 'l', 'e'), 1)]

# Автодополнение
prefix = "app"
matching_suggestions = list(trie.iterkeys(prefix))
print(matching_suggestions)  # Вывод: [('a', 'p', 'p', 'l', 'e')]

# =======================================================================================

# Библиотека marisa-trie

# Предоставляет эффективную реализацию компактных деревьев префиксов в Python. 
# Она может быть полезна при работе с большими объёмами данных, например словарями или наборами 
# строк. Библиотека marisa-trie обладает высокой производительностью и 
# экономично использует память.p

# Установка библиотеки marisa-trie

# Убедитесь, что на вашем компьютере установлен Python.
# Откройте командную строку или терминал.
# Установите библиотеку marisa-trie с помощью команды pip:
# pip install marisa-trie==0.8.0 

import marisa_trie

# Создание экземпляра дерева префиксов
trie = marisa_trie.Trie(["apple", "banana", "orange", "app"])

# Проверка наличия элементов
print("apple" in trie)  # Вывод: True
print("pear" in trie)  # Вывод: False

# Получение значения элемента
print(trie["banana"])  # Вывод: banana

# Поиск всех элементов с заданным префиксом
prefixes = trie.items("app")
print(list(prefixes))  # Вывод: [('app', 0), ('apple', 3)]

# Автодополнение
suggestions = trie.keys("app")
print(list(suggestions))  # Вывод: ['app', 'apple']

# =======================================================================================

# Преимущества деревьев префиксов
# Быстрый поиск и вставка
# Деревья префиксов обеспечивают эффективный поиск и быструю вставку элементов. 
# Время выполнения этих операций пропорционально длине ключа, 
# а не общему количеству элементов в дереве.
# Поддержка поиска по префиксу
# Деревья префиксов позволяют эффективно искать все элементы, которые имеют заданный префикс, 
# что делает их полезными для решения задач автодополнения или поиска.
# Экономия памяти
# Деревья префиксов позволяют эффективнее распоряжаться памятью. 
# За счёт использования общих ветвей для разных слов они позволяют сократить итоговый 
# объём памяти, выделенный для их хранения.
